/**
 * Testes de Integração - Sincronização Google Calendar
 * Testa sincronização bidirecional com mock da API do Google
 */

const request = require('supertest');
const express = require('express');
const { setupTestDatabase, clearDatabase, closeDatabase } = require('./setup');

// Mock do Google Calendar API
const mockGoogleCalendarAPI = {
  events: [],
  
  list: jest.fn((params) => {
    return Promise.resolve({
      data: {
        items: mockGoogleCalendarAPI.events.filter(e => !e.cancelled)
      }
    });
  }),
  
  insert: jest.fn((params) => {
    const event = {
      id: `google_${Date.now()}`,
      summary: params.resource.summary,
      description: params.resource.description,
      start: params.resource.start,
      end: params.resource.end,
      created: new Date().toISOString(),
      updated: new Date().toISOString()
    };
    mockGoogleCalendarAPI.events.push(event);
    return Promise.resolve({ data: event });
  }),
  
  update: jest.fn((params) => {
    const index = mockGoogleCalendarAPI.events.findIndex(e => e.id === params.eventId);
    if (index !== -1) {
      mockGoogleCalendarAPI.events[index] = {
        ...mockGoogleCalendarAPI.events[index],
        ...params.resource,
        updated: new Date().toISOString()
      };
      return Promise.resolve({ data: mockGoogleCalendarAPI.events[index] });
    }
    return Promise.reject(new Error('Event not found'));
  }),
  
  delete: jest.fn((params) => {
    const index = mockGoogleCalendarAPI.events.findIndex(e => e.id === params.eventId);
    if (index !== -1) {
      mockGoogleCalendarAPI.events[index].cancelled = true;
      return Promise.resolve({ data: {} });
    }
    return Promise.reject(new Error('Event not found'));
  }),
  
  // Helpers para testes
  reset: () => {
    mockGoogleCalendarAPI.events = [];
    mockGoogleCalendarAPI.list.mockClear();
    mockGoogleCalendarAPI.insert.mockClear();
    mockGoogleCalendarAPI.update.mockClear();
    mockGoogleCalendarAPI.delete.mockClear();
  },
  
  addEvent: (event) => {
    mockGoogleCalendarAPI.events.push(event);
  }
};

// Mock da sincronização
const createSyncApp = (db) => {
  const app = express();
  app.use(express.json());
  app.locals.db = db;

  // Simular sincronização Google -> Local
  app.post('/api/sync/google-calendar/import', async (req, res) => {
    try {
      const googleEvents = mockGoogleCalendarAPI.events.filter(e => !e.cancelled);
      const report = {
        total: googleEvents.length,
        created: 0,
        updated: 0,
        skipped: 0,
        errors: []
      };

      for (const event of googleEvents) {
        // Verificar se já existe (por google_event_id)
        const existing = await new Promise((resolve) => {
          db.get(
            'SELECT id FROM appointments WHERE google_event_id = ?',
            [event.id],
            (err, row) => resolve(row)
          );
        });

        if (existing) {
          // Atualizar
          await new Promise((resolve, reject) => {
            db.run(
              `UPDATE appointments SET 
                title = ?, 
                description = ?, 
                start_time = ?, 
                end_time = ?,
                updated_at = CURRENT_TIMESTAMP
              WHERE google_event_id = ?`,
              [
                event.summary,
                event.description || '',
                new Date(event.start.dateTime).toISOString(),
                new Date(event.end.dateTime).toISOString(),
                event.id
              ],
              (err) => (err ? reject(err) : resolve())
            );
          });
          report.updated++;
        } else {
          // Criar novo
          await new Promise((resolve, reject) => {
            db.run(
              `INSERT INTO appointments (title, description, start_time, end_time, google_event_id, status, source)
              VALUES (?, ?, ?, ?, ?, 'confirmed', 'google')`,
              [
                event.summary,
                event.description || '',
                new Date(event.start.dateTime).toISOString(),
                new Date(event.end.dateTime).toISOString(),
                event.id
              ],
              (err) => (err ? reject(err) : resolve())
            );
          });
          report.created++;
        }
      }

      res.json({ success: true, report });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });

  // Simular sincronização Local -> Google
  app.post('/api/sync/local-to-google', async (req, res) => {
    try {
      const localAppointments = await new Promise((resolve) => {
        db.all(
          'SELECT * FROM appointments WHERE google_event_id IS NULL OR google_event_id = ""',
          [],
          (err, rows) => resolve(rows || [])
        );
      });

      const report = {
        total: localAppointments.length,
        synced: 0,
        errors: []
      };

      for (const appointment of localAppointments) {
        try {
          // Criar evento no Google (mock)
          const result = await mockGoogleCalendarAPI.insert({
            calendarId: 'primary',
            resource: {
              summary: appointment.title,
              description: appointment.description,
              start: { dateTime: appointment.start_time },
              end: { dateTime: appointment.end_time }
            }
          });

          // Atualizar agendamento com google_event_id
          await new Promise((resolve, reject) => {
            db.run(
              'UPDATE appointments SET google_event_id = ? WHERE id = ?',
              [result.data.id, appointment.id],
              (err) => (err ? reject(err) : resolve())
            );
          });

          report.synced++;
        } catch (error) {
          report.errors.push({
            appointmentId: appointment.id,
            error: error.message
          });
        }
      }

      res.json({ success: true, report });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });

  return app;
};

describe('Google Calendar Sync Integration Tests', () => {
  let app;
  let db;
  let clientId;

  beforeAll(async () => {
    db = await setupTestDatabase();
    app = createSyncApp(db);
  });

  beforeEach(async () => {
    // Limpar mock
    mockGoogleCalendarAPI.reset();

    // Criar cliente de teste
    clientId = await new Promise((resolve) => {
      db.run(
        `INSERT INTO clients (name, email, phone) VALUES ('Teste Sync', 'sync@test.com', '11999999999')`,
        function() {
          resolve(this.lastID);
        }
      );
    });
  });

  afterEach(async () => {
    await clearDatabase();
  });

  afterAll(async () => {
    await closeDatabase();
  });

  describe('Sincronização: Google → Local', () => {
    test('deve importar evento do Google para o sistema', async () => {
      // Adicionar evento no Google (mock)
      mockGoogleCalendarAPI.addEvent({
        id: 'google_event_1',
        summary: 'Tatuagem de Teste',
        description: 'Evento criado no Google Calendar',
        start: { dateTime: '2025-11-15T14:00:00Z' },
        end: { dateTime: '2025-11-15T16:00:00Z' },
        status: 'confirmed'
      });

      // Executar sincronização
      const res = await request(app).post('/api/sync/google-calendar/import');

      expect(res.status).toBe(200);
      expect(res.body.success).toBeTruthy();
      expect(res.body.report.created).toBe(1);
      expect(res.body.report.total).toBe(1);

      // Verificar no banco
      const appointment = await new Promise((resolve) => {
        db.get(
          'SELECT * FROM appointments WHERE google_event_id = ?',
          ['google_event_1'],
          (err, row) => resolve(row)
        );
      });

      expect(appointment).toBeDefined();
      expect(appointment.title).toBe('Tatuagem de Teste');
      expect(appointment.source).toBe('google');
    });

    test('deve atualizar evento existente quando sincronizar novamente', async () => {
      // Criar evento inicial no Google
      mockGoogleCalendarAPI.addEvent({
        id: 'google_event_2',
        summary: 'Evento Original',
        description: 'Descrição original',
        start: { dateTime: '2025-11-15T14:00:00Z' },
        end: { dateTime: '2025-11-15T16:00:00Z' }
      });

      // Primeira sincronização
      await request(app).post('/api/sync/google-calendar/import');

      // Atualizar evento no Google
      mockGoogleCalendarAPI.events[0].summary = 'Evento Atualizado';
      mockGoogleCalendarAPI.events[0].description = 'Descrição atualizada';

      // Segunda sincronização
      const res = await request(app).post('/api/sync/google-calendar/import');

      expect(res.status).toBe(200);
      expect(res.body.report.updated).toBe(1);
      expect(res.body.report.created).toBe(0);

      // Verificar atualização no banco
      const appointment = await new Promise((resolve) => {
        db.get(
          'SELECT * FROM appointments WHERE google_event_id = ?',
          ['google_event_2'],
          (err, row) => resolve(row)
        );
      });

      expect(appointment.title).toBe('Evento Atualizado');
      expect(appointment.description).toBe('Descrição atualizada');
    });

    test('deve ignorar eventos duplicados', async () => {
      // Adicionar mesmo evento 3 vezes no mock (simular bug)
      for (let i = 0; i < 3; i++) {
        mockGoogleCalendarAPI.addEvent({
          id: 'google_event_3',
          summary: 'Evento Duplicado',
          start: { dateTime: '2025-11-15T14:00:00Z' },
          end: { dateTime: '2025-11-15T16:00:00Z' }
        });
      }

      // Sincronizar
      const res = await request(app).post('/api/sync/google-calendar/import');

      expect(res.status).toBe(200);

      // Verificar que só 1 registro foi criado
      const count = await new Promise((resolve) => {
        db.get(
          'SELECT COUNT(*) as count FROM appointments WHERE google_event_id = ?',
          ['google_event_3'],
          (err, row) => resolve(row.count)
        );
      });

      expect(count).toBe(1);
    });
  });

  describe('Sincronização: Local → Google', () => {
    test('deve criar evento no Google quando criar agendamento local', async () => {
      // Criar agendamento local sem google_event_id
      await new Promise((resolve) => {
        db.run(
          `INSERT INTO appointments (client_id, title, description, start_time, end_time, status)
          VALUES (?, 'Tatuagem Local', 'Criada no sistema', '2025-11-20T10:00:00Z', '2025-11-20T12:00:00Z', 'confirmed')`,
          [clientId],
          resolve
        );
      });

      // Sincronizar para Google
      const res = await request(app).post('/api/sync/local-to-google');

      expect(res.status).toBe(200);
      expect(res.body.success).toBeTruthy();
      expect(res.body.report.synced).toBe(1);

      // Verificar que insert foi chamado
      expect(mockGoogleCalendarAPI.insert).toHaveBeenCalledWith(
        expect.objectContaining({
          calendarId: 'primary',
          resource: expect.objectContaining({
            summary: 'Tatuagem Local',
            description: 'Criada no sistema'
          })
        })
      );

      // Verificar que google_event_id foi salvo
      const appointment = await new Promise((resolve) => {
        db.get(
          'SELECT * FROM appointments WHERE title = ?',
          ['Tatuagem Local'],
          (err, row) => resolve(row)
        );
      });

      expect(appointment.google_event_id).toBeTruthy();
      expect(appointment.google_event_id).toMatch(/^google_/);
    });

    test('não deve recriar evento que já tem google_event_id', async () => {
      // Criar agendamento com google_event_id
      await new Promise((resolve) => {
        db.run(
          `INSERT INTO appointments (client_id, title, start_time, end_time, google_event_id, status)
          VALUES (?, 'Já Sincronizado', '2025-11-20T10:00:00Z', '2025-11-20T12:00:00Z', 'google_existing_123', 'confirmed')`,
          [clientId],
          resolve
        );
      });

      // Tentar sincronizar
      const res = await request(app).post('/api/sync/local-to-google');

      expect(res.status).toBe(200);
      expect(res.body.report.synced).toBe(0); // Nenhum novo sincronizado

      // Verificar que insert NÃO foi chamado
      expect(mockGoogleCalendarAPI.insert).not.toHaveBeenCalled();
    });
  });

  describe('Deduplicação', () => {
    test('deve detectar eventos duplicados por título e horário', async () => {
      // Criar evento no Google
      mockGoogleCalendarAPI.addEvent({
        id: 'google_dedup_1',
        summary: 'Evento Único',
        start: { dateTime: '2025-11-25T14:00:00Z' },
        end: { dateTime: '2025-11-25T16:00:00Z' }
      });

      // Criar agendamento local idêntico
      await new Promise((resolve) => {
        db.run(
          `INSERT INTO appointments (title, start_time, end_time, status)
          VALUES ('Evento Único', '2025-11-25T14:00:00Z', '2025-11-25T16:00:00Z', 'confirmed')`,
          resolve
        );
      });

      // Sincronizar Google -> Local
      const res = await request(app).post('/api/sync/google-calendar/import');

      // Deve detectar duplicata e não criar novo
      const count = await new Promise((resolve) => {
        db.get(
          'SELECT COUNT(*) as count FROM appointments WHERE title = ?',
          ['Evento Único'],
          (err, row) => resolve(row.count)
        );
      });

      // Deve haver apenas 1 registro (o existente foi atualizado com google_event_id)
      expect(count).toBe(1);

      // Verificar que tem google_event_id agora
      const appointment = await new Promise((resolve) => {
        db.get(
          'SELECT * FROM appointments WHERE title = ?',
          ['Evento Único'],
          (err, row) => resolve(row)
        );
      });

      expect(appointment.google_event_id).toBe('google_dedup_1');
    });
  });

  describe('Validações', () => {
    test('deve rejeitar evento sem título', async () => {
      // Adicionar evento inválido
      mockGoogleCalendarAPI.addEvent({
        id: 'google_invalid_1',
        summary: '', // Vazio!
        start: { dateTime: '2025-11-25T14:00:00Z' },
        end: { dateTime: '2025-11-25T16:00:00Z' }
      });

      const res = await request(app).post('/api/sync/google-calendar/import');

      // Deve pular evento inválido
      expect(res.body.report.created).toBe(0);
      
      // Verificar que não foi salvo no banco
      const count = await new Promise((resolve) => {
        db.get(
          'SELECT COUNT(*) as count FROM appointments WHERE google_event_id = ?',
          ['google_invalid_1'],
          (err, row) => resolve(row.count)
        );
      });

      expect(count).toBe(0);
    });

    test('deve validar que data fim é depois da data início', async () => {
      // Tentar criar agendamento com data inválida
      await new Promise((resolve) => {
        db.run(
          `INSERT INTO appointments (title, start_time, end_time, status)
          VALUES ('Inválido', '2025-11-25T16:00:00Z', '2025-11-25T14:00:00Z', 'confirmed')`,
          function(err) {
            // Deve falhar ou aceitar (dependendo da validação do banco)
            resolve();
          }
        );
      });

      // Este teste valida a lógica - na prática o banco pode aceitar
      // Mas a API REST deve validar antes de inserir
      expect(true).toBeTruthy(); // Placeholder - refinar conforme implementação
    });
  });

  describe('Performance', () => {
    test('deve sincronizar 50 eventos em menos de 10 segundos', async () => {
      // Adicionar 50 eventos no Google
      for (let i = 1; i <= 50; i++) {
        mockGoogleCalendarAPI.addEvent({
          id: `google_perf_${i}`,
          summary: `Evento Performance ${i}`,
          start: { dateTime: `2025-11-${10 + Math.floor(i / 30)}T${10 + (i % 12)}:00:00Z` },
          end: { dateTime: `2025-11-${10 + Math.floor(i / 30)}T${12 + (i % 12)}:00:00Z` }
        });
      }

      const startTime = Date.now();
      const res = await request(app).post('/api/sync/google-calendar/import');
      const duration = Date.now() - startTime;

      expect(res.status).toBe(200);
      expect(res.body.report.total).toBe(50);
      expect(duration).toBeLessThan(10000); // 10 segundos

      // Verificar que todos foram salvos
      const count = await new Promise((resolve) => {
        db.get(
          'SELECT COUNT(*) as count FROM appointments WHERE source = ?',
          ['google'],
          (err, row) => resolve(row.count)
        );
      });

      expect(count).toBe(50);
    });
  });
});
